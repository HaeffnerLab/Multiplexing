"""The Virtual Time Tagger is used to replay stored FileWriter files.
From the user perspective, there is no difference between the time tag stream of the physical Time
Tagger and the stream generated by the Virtual Time Tagger from a file. In this example, we first
store the data of a physical Correlation measurement using the FileWriter and SynchronizedMeasurements.
Later, we will be able to repeat the Correlation measurement based and to adjust the measurement
parameters."""

import os
from matplotlib import pyplot as plt
from datetime import datetime
import TimeTagger
import matplotlib
import asyncio
import numpy as np
from ipywidgets import Button
import plotly.graph_objs as go
import pprint
from matplotlib.animation import FuncAnimation

matplotlib.rcParams.update(
        {"font.family": "STIXGeneral",
         "xtick.labelsize": 20,
         "xtick.direction": "in",
         "xtick.major.pad": 8,
         "xtick.top": True,
         "ytick.labelsize": 20,
         "ytick.direction": "in",
         "ytick.right": True,
         "axes.labelsize": 20,
         "axes.labelpad": 10,
         "axes.grid": True
    }
)

# Useful function for printing what is stored in the folder and display the files that are just created
def print_folder_content(folder):
    """Print filename and size of the files in the folder."""
    print("Filename            |       Size")
    print("--------------------+-----------")
    filenames = os.listdir(folder)
    for filename in [filenames[-1]] + filenames[:-1]:
        print("{:<20}|{:>8.1f} kB".format(filename, os.path.getsize(folder + os.sep + filename)/1024))

feature = "9_ions"

# Getting the current date and time
now = datetime.now()
# Extracting the date, hour, and minute
current_date = now.date()
current_hour = now.hour
current_minute = now.minute
# Converting to a char string
formatted_string = f"Date {current_date}, Time {current_hour}-{current_minute}"

# Specify the directory where you want to save the files and make sure the directory exists
save_directory = 'D:/Google_Drive/Simulation_Code/TimeTagger API examples/python/1-Quickstart/3-dump-and-reanalyze-time-tags'
os.makedirs(save_directory, exist_ok=True)
filename=save_directory + "/filewriter" + formatted_string + "_" + feature
# filename="D:/Google_Drive/Experimental_Data/Multiplexing/g2_data" + "/filewriterDate 2024-01-03, Time 13-49.1"

# Create a TimeTagger instance to control your hardware
tagger = TimeTagger.createTimeTagger()

# # Start of the first round with SynchronizedMeasurements
# print("\nThe first round uses the FileWriter with SynchronizedMeasurements.")
# input("-> Press Enter to run")

# We synchronize the FileWriter to our Correlation measurement to run the
# repeated measurements on the very same set of time tags as the original one.
synchronized = TimeTagger.SynchronizedMeasurements(tagger=tagger)
Counter = TimeTagger.Counter(tagger=tagger, channels=[1, 3], binwidth=int(300 * 1e9), n_values=100)
filewriter = TimeTagger.FileWriter(tagger=synchronized.getTagger(),
                                   filename=filename,
                                   channels=[1, 2, 3])

# Initialize lists to store PMT data
data_pmt1 = []
data_pmt2 = []

# Create a figure
fig = plt.figure()

# Start the measurements
synchronized.startFor(int(0.3 * 3600 * 1e12))

# Loop to update the plot
while synchronized.isRunning():
    data = Counter.getDataNormalized()
    if data is not None and len(data) >= 2:
        data_pmt1 = data[0]
        data_pmt2 = data[1]

    fig.clear()
    plt.plot(data_pmt1, label='PMT1 Counts', color='blue')
    plt.plot(data_pmt2, label='PMT2 Counts', color='green')

    plt.xlabel("Time bins")
    plt.ylabel("Counts")
    plt.legend()
    plt.pause(0.1)  # Update every 0.1 seconds

# Close the plot after the loop ends
plt.close(fig)

# Now the data acquisition is done and we can release the measurements
del synchronized
del Counter
del filewriter
TimeTagger.freeTimeTagger(tagger)
del tagger

# The Virtual Time Tagger is initialized similar to the physical one
tagger = TimeTagger.createTimeTaggerVirtual()
fig = plt.figure()

# The while loop allows us to repeat the replay several times
i = 1
while i == 1:
    i += 1
    # print("\nInput data for the data replay")

    # # The request_values function allows us to input our data
    # corr_param, replay_speed, replay_begin, replay_duration = request_values()
    trigger_channel = 2
    PMT_channel1 = 1
    PMT_channel2 = 3
    binwidth = 50 * 1e3  # Adjust binwidth as needed
    n_bins = 3000   # Adjust number of bins as needed
    # DELAY = 200 * 1e3 # The gate time is 1us

    open_gate = TimeTagger.DelayedChannel(tagger=tagger, input_channel=trigger_channel, delay=2000 * 1e3)
    open_gate_channel = open_gate.getChannel()
    close_gate = TimeTagger.DelayedChannel(tagger=tagger, input_channel=open_gate_channel, delay=200 * 1e3)
    close_gate_channel = close_gate.getChannel()

    gated_PMT_channel1 = TimeTagger.GatedChannel(tagger=tagger, input_channel=PMT_channel1, gate_start_channel=open_gate_channel, gate_stop_channel=close_gate_channel)
    gated_PMT_channel2 = TimeTagger.GatedChannel(tagger=tagger, input_channel=PMT_channel2, gate_start_channel=open_gate_channel, gate_stop_channel=close_gate_channel)

    # Start the correlation measurement
    # We can pass virtual_tagger to the "tagger" argument of any measurement class constructor
    corr = TimeTagger.Correlation(tagger=tagger, channel_1=gated_PMT_channel1.getChannel(), channel_2=gated_PMT_channel2.getChannel(), binwidth=binwidth, n_bins=n_bins)
    # measurement_time = int(0.001 * 3600 * 1e12)  # Adjust measurement time as needed

    # In general, the data are replayed at the same speed as they have been acquired.
    # You can modify the speed by a factor or replay them as fast es possible by speed < 0
    tagger.setReplaySpeed(speed=-1)

    # Start the replay
    tagger.replay(file=filename)

    while not tagger.waitForCompletion(timeout=0):
        fig.clear()
        plt.plot(corr.getIndex(), corr.getData())
        plt.xlabel("Time difference [ps]")
        plt.ylabel("Counts")
        # plt.show()
        plt.pause(.1)

    # Get the correlation data
    g2_data = corr.getData()
    index = corr.getIndex() / 1e6

    # Converting to a char string
    formatted_string = f"Date {current_date}, Time {current_hour}-{current_minute}"
    print(formatted_string)

    np.save('corr_meas_'+feature+formatted_string+'.npy', index, g2_data)

    # Plot the g(2) function
    plt.plot(index, g2_data)
    plt.title(feature+" second-order correlation function", fontdict={'size':20})
    plt.xlabel("Delay (us)")
    plt.ylabel("Counts/bin")
    plt.show()

    # Getting the current date and time
    now = datetime.now()

    # Extracting the date, hour, and minute
    current_date = now.date()
    current_hour = now.hour
    current_minute = now.minute

    np.save('corr.getData_'+feature+formatted_string+'.npy', corr.getData())
    np.save('corr.getIndex_'+feature+formatted_string+'.npy', corr.getIndex())

# Free the TimeTagger
TimeTagger.freeTimeTagger(tagger)