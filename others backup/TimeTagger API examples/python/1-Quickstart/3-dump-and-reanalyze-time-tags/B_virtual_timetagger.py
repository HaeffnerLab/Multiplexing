# """The Virtual Time Tagger is used to replay stored FileWriter files.
# From the user perspective, there is no difference between the time tag stream of the physical Time
# Tagger and the stream generated by the Virtual Time Tagger from a file. In this example, we first
# store the data of a physical Correlation measurement using the FileWriter and SynchronizedMeasurements.
# Later, we will be able to repeat the Correlation measurement based and to adjust the measurement
# parameters."""

# import tempfile
# import os
# from matplotlib import pyplot as plt
# import TimeTagger

# def request_values():
#     """Request input for measurement and replay parameters and evaluate the user input."""
#     parameters = dict()
#     try:
#         parameters["binwidth"] = max(1, int(input("-> Binwidth (ps): ")))
#     except ValueError:
#         print("Default value will be used.")
#     try:
#         parameters["n_bins"] = max(1, int(input("-> Number of bins: ")))
#     except ValueError:
#         print("Default value will be used.")
#     try:
#         speed = float(input("-> Replay speed (factor, <0 => max): "))
#     except ValueError:
#         print("No or bad input, we'll use a replay speed of 1")
#         speed = 1
#     try:
#         begin = int(input("-> Begin replay at (ps): "))
#     except ValueError:
#         print("No or bad input, we'll start at the beginning = 0")
#         begin = 1
#     try:
#         duration = int(input("-> Replay duration (ps, -1 = all): "))
#     except ValueError:
#         print("No or bad input, we'll replay all data.")
#         duration = -1
#     return parameters, speed, begin, duration

# # Create a TimeTagger instance to control your hardware
# tagger = TimeTagger.createTimeTagger()

# # Activate test signal on channel 1 and 2
# tagger.setTestSignal(1, True)
# tagger.setTestSignal(2, True)

# # We create a temporary folder as storage for the FileWriter files
# tempdir = tempfile.TemporaryDirectory()
# filename = tempdir.name + os.sep + "filewriter.ttbin"

# # We synchronize the FileWriter to our Correlation measurement to run the
# # repeated measurements on the very same set of time tags as the original one.
# synchronized = TimeTagger.SynchronizedMeasurements(tagger=tagger)
# corr = TimeTagger.Correlation(tagger=synchronized.getTagger(),
#                               channel_1=1,
#                               channel_2=2)
# filewriter = TimeTagger.FileWriter(tagger=synchronized.getTagger(),
#                                    filename=filename,
#                                    channels=[1, 2])

# # We let the measurements run for 10 s and watch the data accumulation
# fig = plt.figure()
# synchronized.startFor(int(1E13))
# while synchronized.isRunning():
#     fig.clear()
#     plt.plot(corr.getIndex(), corr.getData())
#     plt.xlabel("Time difference [ps]")
#     plt.ylabel("Counts")
#     plt.pause(.1)

# # Now the data acquisition is done and we can release the measurements
# del synchronized
# del corr
# del filewriter
# TimeTagger.freeTimeTagger(tagger)
# del tagger

# # The Virtual Time Tagger is initialized similar to the physical one
# virtual_tagger = TimeTagger.createTimeTaggerVirtual()

# # The while loop allows us to repeat the replay several times
# while True:
#     print("\nInput data for the data replay")

#     # The request_values function allows us to input our data
#     corr_param, replay_speed, replay_begin, replay_duration = request_values()

#     # We can pass virtual_tagger to the "tagger" argument of any measurement class constructor
#     corr_replay = TimeTagger.Correlation(tagger=virtual_tagger,
#                                          channel_1=1,
#                                          channel_2=2,
#                                          **corr_param)

#     # In general, the data are replayed at the same speed as they have been acquired.
#     # You can modify the speed by a factor or replay them as fast es possible by speed < 0
#     virtual_tagger.setReplaySpeed(speed=replay_speed)

#     # Start the replay
#     virtual_tagger.replay(file=filename,
#                           begin=replay_begin,
#                           duration=replay_duration)

#     # To check if the replay is finished, use the waitForCompletion method. If you want to do
#     # something during the measurement (such as watching the accumulation), use a while loop and
#     # timeout=0. If you just want to wait for completion, you can skip the loop and use
#     # timeout=-1 instead.
#     while not virtual_tagger.waitForCompletion(timeout=0):
#         fig.clear()
#         plt.plot(corr_replay.getIndex(), corr_replay.getData())
#         plt.xlabel("Time difference [ps]")
#         plt.ylabel("Counts")
#         plt.pause(.1)

#     # Ask if the user wants to repeat the replay with another set of parameters.
#     cont = ""
#     for i in range(3):
#         cont = input("Try again? (y/n) ")
#         if cont and cont in "ynYN":
#             break
#     if cont not in "yY":
#         break

# tempdir.cleanup()

# TimeTagger.freeTimeTagger(virtual_tagger)

"""The Virtual Time Tagger is used to replay stored FileWriter files.
From the user perspective, there is no difference between the time tag stream of the physical Time
Tagger and the stream generated by the Virtual Time Tagger from a file. In this example, we first
store the data of a physical Correlation measurement using the FileWriter and SynchronizedMeasurements.
Later, we will be able to repeat the Correlation measurement based and to adjust the measurement
parameters."""

import os
from matplotlib import pyplot as plt
from datetime import datetime
import TimeTagger
import matplotlib
import asyncio
import numpy as np
from ipywidgets import Button
import plotly.graph_objs as go
import pprint

matplotlib.rcParams.update(
        {"font.family": "STIXGeneral",
         "xtick.labelsize": 20,
         "xtick.direction": "in",
         "xtick.major.pad": 8,
         "xtick.top": True,
         "ytick.labelsize": 20,
         "ytick.direction": "in",
         "ytick.right": True,
         "axes.labelsize": 20,
         "axes.labelpad": 10,
         "axes.grid": True
    }
)

# def request_values():
#     """Request input for measurement and replay parameters and evaluate the user input."""
#     parameters = dict()
#     try:
#         parameters["binwidth"] = max(1, int(input("-> Binwidth (ps): ")))
#     except ValueError:
#         print("Default value will be used.")
#     try:
#         parameters["n_bins"] = max(1, int(input("-> Number of bins: ")))
#     except ValueError:
#         print("Default value will be used.")
#     try:
#         speed = float(input("-> Replay speed (factor, <0 => max): "))
#     except ValueError:
#         print("No or bad input, we'll use a replay speed of 1")
#         speed = 1
#     try:
#         begin = int(input("-> Begin replay at (ps): "))
#     except ValueError:
#         print("No or bad input, we'll start at the beginning = 0")
#         begin = 1
#     try:
#         duration = int(input("-> Replay duration (ps, -1 = all): "))
#     except ValueError:
#         print("No or bad input, we'll replay all data.")
#         duration = -1
#     return parameters, speed, begin, duration

# Useful function for printing what is stored in the folder and display the files that are just created
def print_folder_content(folder):
    """Print filename and size of the files in the folder."""
    print("Filename            |       Size")
    print("--------------------+-----------")
    filenames = os.listdir(folder)
    for filename in [filenames[-1]] + filenames[:-1]:
        print("{:<20}|{:>8.1f} kB".format(filename, os.path.getsize(folder + os.sep + filename)/1024))

feature = "8_ions"

# Getting the current date and time
now = datetime.now()
# Extracting the date, hour, and minute
current_date = now.date()
current_hour = now.hour
current_minute = now.minute
# Converting to a char string
formatted_string = f"Date {current_date}, Time {current_hour}-{current_minute}"

# Specify the directory where you want to save the files and make sure the directory exists
save_directory = 'D:/Google_Drive/Simulation_Code/TimeTagger API examples/python/1-Quickstart/3-dump-and-reanalyze-time-tags'
os.makedirs(save_directory, exist_ok=True)
filename=save_directory + "/filewriter" + formatted_string + "_" + feature
# filename="D:/Google_Drive/Experimental_Data/Multiplexing/g2_data" + "/filewriterDate 2024-01-03, Time 13-49.1"

''''''
# Create a TimeTagger instance to control your hardware
tagger = TimeTagger.createTimeTagger()

# # Enable the test signal on channels 1 and 2
# tagger.setTestSignal(1, True)
# tagger.setTestSignal(2, True)

# Start of the first round with SynchronizedMeasurements
print("\nThe first round uses the FileWriter with SynchronizedMeasurements.")
input("-> Press Enter to run")

# We synchronize the FileWriter to our Correlation measurement to run the
# repeated measurements on the very same set of time tags as the original one.
synchronized = TimeTagger.SynchronizedMeasurements(tagger=tagger)
filewriter = TimeTagger.FileWriter(tagger=synchronized.getTagger(),
                                   filename=filename,
                                   channels=[1, 2, 3])
synchronized.startFor(int(0.3 * 3600 * 1e12))
synchronized.waitUntilFinished()

# # We let the measurements run for 10 s and watch the data accumulation
# fig = plt.figure()
# synchronized.startFor(int(0.01 * 3600 * 1e12))
# while synchronized.isRunning():
#     fig.clear()
#     plt.plot(corr.getIndex(), corr.getData())
#     plt.xlabel("Time difference [ps]")
#     plt.ylabel("Counts")
#     plt.pause(.1)

# Now the data acquisition is done and we can release the measurements
del synchronized
del filewriter
TimeTagger.freeTimeTagger(tagger)
del tagger
''''''

# The Virtual Time Tagger is initialized similar to the physical one
tagger = TimeTagger.createTimeTaggerVirtual()
fig = plt.figure()

# The while loop allows us to repeat the replay several times
i = 1
while i == 1:
    i += 1
    # print("\nInput data for the data replay")

    # # The request_values function allows us to input our data
    # corr_param, replay_speed, replay_begin, replay_duration = request_values()
    trigger_channel = 2
    PMT_channel1 = 1
    PMT_channel2 = 3
    binwidth = 50 * 1e3  # Adjust binwidth as needed
    n_bins = 3000   # Adjust number of bins as needed
    # DELAY = 200 * 1e3 # The gate time is 1us

    open_gate = TimeTagger.DelayedChannel(tagger=tagger, input_channel=trigger_channel, delay=2000 * 1e3)
    open_gate_channel = open_gate.getChannel()
    close_gate = TimeTagger.DelayedChannel(tagger=tagger, input_channel=open_gate_channel, delay=200 * 1e3)
    close_gate_channel = close_gate.getChannel()

    gated_PMT_channel1 = TimeTagger.GatedChannel(tagger=tagger, input_channel=PMT_channel1, gate_start_channel=open_gate_channel, gate_stop_channel=close_gate_channel)
    gated_PMT_channel2 = TimeTagger.GatedChannel(tagger=tagger, input_channel=PMT_channel2, gate_start_channel=open_gate_channel, gate_stop_channel=close_gate_channel)

    # Start the correlation measurement
    # We can pass virtual_tagger to the "tagger" argument of any measurement class constructor
    corr = TimeTagger.Correlation(tagger=tagger, channel_1=gated_PMT_channel1.getChannel(), channel_2=gated_PMT_channel2.getChannel(), binwidth=binwidth, n_bins=n_bins)
    # measurement_time = int(0.001 * 3600 * 1e12)  # Adjust measurement time as needed

    # In general, the data are replayed at the same speed as they have been acquired.
    # You can modify the speed by a factor or replay them as fast es possible by speed < 0
    tagger.setReplaySpeed(speed=-1)

    # Start the replay
    tagger.replay(file=filename)

    # To check if the replay is finished, use the waitForCompletion method. If you want to do
    # something during the measurement (such as watching the accumulation), use a while loop and
    # timeout=0. If you just want to wait for completion, you can skip the loop and use
    # timeout=-1 instead.
    while not tagger.waitForCompletion(timeout=0):
        fig.clear()
        plt.plot(corr.getIndex(), corr.getData())
        plt.xlabel("Time difference [ps]")
        plt.ylabel("Counts")
        plt.pause(.1)

    # Get the correlation data
    g2_data = corr.getData()
    index = corr.getIndex() / 1e6

    # Converting to a char string
    formatted_string = f"Date {current_date}, Time {current_hour}-{current_minute}"
    print(formatted_string)

    np.save('corr_meas_'+feature+formatted_string+'.npy', index, g2_data)

    # Plot the g(2) function
    plt.plot(index, g2_data)
    plt.title(feature+" second-order correlation function", fontdict={'size':20})
    plt.xlabel("Delay (us)")
    plt.ylabel("Counts/bin")
    plt.show()

    # Getting the current date and time
    now = datetime.now()

    # Extracting the date, hour, and minute
    current_date = now.date()
    current_hour = now.hour
    current_minute = now.minute

    np.save('corr.getData_'+feature+formatted_string+'.npy', corr.getData())
    np.save('corr.getIndex_'+feature+formatted_string+'.npy', corr.getIndex())

# Free the TimeTagger
TimeTagger.freeTimeTagger(tagger)